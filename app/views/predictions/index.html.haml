:ruby
  colours = ["F00", "0F0", "00F", "FF0", "F0F", "0FF"]
  series = @predictions.map{|p| p.values_to_a}
  series_options = series.map{|x| {}}

- content_for :head do
  = stylesheet_link_tag 'prediction'
  = javascript_include_tag :defaults
  = sprocket_include_tag 'backcasting'
  = javascript_include_tag 'backcasting'
  :javascript
    // let's prepare the json data produced on the ruby side
    var chart_data = {
      series: #{series.to_json},
      series_options: #{series_options.to_json},
      colours: #{colours.to_json}
    }

    // information about the slider
    var input_element = {
      growth: #{@input_element.growth?.to_json},
      id: #{@input_element.id}
    }

    var scenario = {
      start_year: 2010,
      end_year: #{@end_year.to_i}
    }

.prediction
  .intro= t('prediction.intro_text')
  .slider_title= t('prediction.chart_header')
    
  .upper_block
    .chart#backcasting
    .available_predictions
      %table
        - @predictions.each do |p|
          %tr
            %td= radio_button_tag :prediction_id, p.id, (p.id == @prediction.id)
            %td
              .colour{:style => "background: ##{cycle(*colours)}"}
            %td
              #{p.user.try(:name)},
              - if p.user.try(:company_school)
                #{p.user.company_school},
              = p.title
              - if v = p.last_value
                (#{"%0.f" % v.value}#{@input_element.unit} in #{v.year})
              - if current_user.try(:admin?)
                = link_to 'edit', edit_admin_prediction_path(p), :target => '_new'
        %tr.user_prediction
          %td= radio_button_tag :prediction_id, ''
          %td
            .colour{:style => "background: ##{cycle(*colours)}"}
          %td Your prediction
  .prediction_details
    = render @prediction
  .buttons
    = button_to_function "apply", "alert('Not implemented yet')"
    = button_to_function "back", "parent.$.fancybox.close()"
