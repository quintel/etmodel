= stylesheet_link_tag 'prediction'
= javascript_include_tag :defaults
= sprocket_include_tag 'backcasting'
:ruby
  colours = ["F00", "0F0", "00F", "FF0", "F0F", "0FF"]
  series = @input_element.predictions.map{|p| p.values_to_a}
  series_options = series.map{|x| {}}
  # To show the vertical bar representing the scenario end year I must add the
  # serie options as the last item.
  # TODO: refactor
  if @end_year && @end_year.to_i != 2050
    series << [[@end_year, @min_value], [@end_year, @max_value]]
    series_options << { lineWidth: 1, color: "ff0000", markerOptions: { show: false}}
  end

.prediction
  .intro
    Hier kun je jouw scenario vergelijken met verwachtingen van experts. Jouw scenario valt binnen/buiten de expertverwachtingen.
  .slider_title= @input_element.name
  .upper_block
    .chart#backcasting
    .available_predictions
      %table
        - @input_element.predictions.each do |p|
          %tr
            %td= radio_button_tag :prediction_id, p.id, (p.id == @prediction.id)
            %td
              .colour{:style => "background: #{cycle(*colours)}"}
            %td
              #{p.user.try(:name)},
              - if p.user.try(:company_school)
                #{p.user.company_school},
              = p.title
              - if v = p.last_value
                (#{"%0.f" % v.value}#{@input_element.unit} in #{v.year})
              - if current_user.try(:admin?)
                = link_to 'edit', edit_admin_prediction_path(p), :target => '_new'
        %tr.user_prediction
          %td
          %td
            .colour{:style => "background: #{cycle(*colours)}"}
          %td Your prediction
  .prediction_details
    = render @prediction
  .buttons
    = button_to_function "apply", "alert('Not implemented yet')"
    = button_to_function "back", "parent.$.fancybox.close()"

:javascript
  $(function(){

    // let's prepare the json data produced on the ruby side
    var chart_data = {
      series: #{series.to_json},
      series_options: #{series_options.to_json},
      colours: #{colours.to_json}
    }

    // information about the slider
    var input_element = {
      growth: #{@input_element.growth?.to_json},
      scenario_duration: #{@end_year.to_i - 2010}
    }

    // when sliders represent a growth I must compute the end value
    var _calculate_user_value = function(x) {
      if(!input_element.growth) { return x; }
      var number_of_years = input_element.scenario_duration;
      var base = 1 + x / 100.0;
      var out = Math.pow(base, number_of_years) * 100;
      return out;
    }

    // returns a serie in the jqplot format
    var build_user_value_chart_serie = function(user_value) {
      var out;
      if(!input_element.growth) {
        out = [[2010,0],  [#{@end_year}, user_value]];
      } else {
        out = [[2010,100],[#{@end_year}, _calculate_user_value(user_value)]];
      }
      return out;
    }

    // let's get the current slider value
    if (parent && parent.input_elements) {
      var user_value = parent.input_elements.get(#{@input_element.id}).get('user_value');
      var user_serie = build_user_value_chart_serie(user_value);
      chart_data.series.push(user_serie);
      $("tr.user_prediction").show();
    }

    // ajax loading of prediction details
    $("input[type=radio]").click(function(){
      var prediction_id = $(this).val();
      var url = "/predictions/" + prediction_id;
      $(".prediction_details").busyBox({spinner: '<img src="/images/layout/ajax-loader.gif" />'});
      $(".prediction_details").load(url, function() {
        $(".prediction_details").busyBox('close');
      });
    });
    
    // Let's plot the chart
    $.jqplot("backcasting", chart_data.series, {
        grid: {
          background: '#ffffff',
          borderWidth: 0,
          borderColor: '#ffffff',
          shadow: false
        },
        axes:{
          xaxis:{tickOptions:{formatString:'%.0f'}},
          yaxis:{tickOptions:{formatString:'%.0f'}}
        },
        seriesColors: chart_data.colours,
        series: chart_data.series_options,
        seriesDefaults : {
          markerOptions: { show: false }
        }
      }
    );
    
    // extra info links
    $(".more_info a").live('click', function(event){
      event.preventDefault();
      $(this).parent().find(".inline_description").toggle();
    });
  });